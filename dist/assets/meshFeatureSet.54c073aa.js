var e=Object.defineProperty,t=Object.defineProperties,n=Object.getOwnPropertyDescriptors,r=Object.getOwnPropertySymbols,o=Object.prototype.hasOwnProperty,s=Object.prototype.propertyIsEnumerable,i=(t,n,r)=>n in t?e(t,n,{enumerable:!0,configurable:!0,writable:!0,value:r}):t[n]=r,a=(e,t)=>{for(var n in t||(t={}))o.call(t,n)&&i(e,n,t[n]);if(r)for(var n of r(t))s.call(t,n)&&i(e,n,t[n]);return e};import{aq as l,ab as c,gQ as f,bX as u,eJ as p,z as h,qf as g,qg as m,nR as d,bf as x,aA as y,bh as v,a as w,f3 as b,k0 as A,mV as R,g9 as F,ga as M,g2 as O,gy as j,fD as P,bY as z,f$ as L,gi as C,gx as S,h4 as k,gd as I,b_ as $,eu as U,mv as E,nx as T,al as B,H as D,a6 as G,y as Z,n as N,c2 as q,a9 as J,E as X}from"./vendor.9770a310.js";import{a as Y,q as V,v as W,x as _,k as H}from"./axisAngleDegrees.427db55f.js";import{y as Q,f as K,p as ee}from"./MeshComponent.39d8495e.js";import{r as te,M as ne,x as re,k as oe,O as se}from"./georeference.0e6c263d.js";import{o as ie}from"./triangulationUtils.57bae97c.js";import{v as ae,F as le,B as ce,M as fe,_ as ue,R as pe}from"./projection.9c98dd23.js";import"./vec33.fc83c3d5.js";import"./earcut.b5c0cad1.js";import"./deduplicate.a6019262.js";const he=l.getLogger("esri.geometry.support.meshUtils.centerAt");function ge(e,t,n){var r;if(!e.vertexAttributes||!e.vertexAttributes.position)return;const o=null!=(r=null==n?void 0:n.origin)?r:e.origin;c(e.transform)?(null!=(null==n?void 0:n.geographic)&&n.geographic!==e.transform.geographic&&he.warn(`Specifying the 'geographic' parameter (${n.geographic}) different from the Mesh transform setting (${e.transform.geographic}) is not supported`),function(e,t,n){const r=t.x-n.x,o=t.y-n.y,s=t.hasZ&&n.hasZ?t.z-n.z:0,i=e.origin;e.origin=[i[0]+r,i[1]+o,i[2]+s]}(e.transform,t,o)):te(e.spatialReference,n)?function(e,t,n){const r=ne(e.vertexAttributes,n,{geographic:!0}),{position:o,normal:s,tangent:i}=re(r,t,{geographic:!0});e.vertexAttributes.position=o,e.vertexAttributes.normal=s,e.vertexAttributes.tangent=i,e.vertexAttributesChanged()}(e,t,o):function(e,t,n){const r=de,o=me;if(f(t,o,e.spatialReference)){if(!f(n,r,e.spatialReference)){const t=e.origin;r[0]=t.x,r[1]=t.y,r[2]=t.z,he.error(`Failed to project specified origin (wkid:${n.spatialReference.wkid}) to mesh spatial reference (wkid:${e.spatialReference.wkid}).`)}(function(e,t,n){if(e)for(let r=0;r<e.length;r+=3)for(let o=0;o<3;o++)e[r+o]+=t[o]-n[o]})(e.vertexAttributes.position,o,r),e.vertexAttributesChanged()}else he.error(`Failed to project centerAt location (wkid:${t.spatialReference.wkid}) to mesh spatial reference (wkid:${e.spatialReference.wkid})`)}(e,t,o)}const me=u(),de=u();function xe(e){const t=m(e.url);return n=>{var r;const o=g(n,t,t),s=o?o.replace(/^ *\.\//,""):null;return null!=(r=e.files.get(s))?r:n}}async function ye(e,t){return e instanceof Blob?ve.fromBlob(e):"string"==typeof e?new ve(e):Array.isArray(e)?async function(e,t){const n=new Map;let r=null;const o=await d(e.map((async e=>({name:e.name,source:await ye(e instanceof Blob?e:e.source,t)})))),s=[];for(const i of o)i&&(x(t)?i.source.dispose():s.push(i));y(t);for(const{name:i,source:a}of s)(v(r)||/\.(gltf|glb)/i.test(i))&&(r=a.url),n.set(i,a.url),a.files&&a.files.forEach(((e,t)=>n.set(t,e)));if(v(r))throw new w("mesh-load-external:missing-files","Missing files to load external mesh source");return new ve(r,(()=>s.forEach((({source:e})=>e.dispose()))),n)}(e,t):async function(e,t){const{default:n}=await p(import("./vendor.9770a310.js").then((function(e){return e.s4})),t),r="string"==typeof e.multipart[0]?await Promise.all(e.multipart.map((async e=>(await n(e,{responseType:"array-buffer"})).data))):e.multipart;return ve.fromBlob(new Blob(r))}(e,t)}class ve{constructor(e,t=(()=>{}),n=new Map){this.url=e,this.dispose=t,this.files=n}static fromBlob(e){const t=URL.createObjectURL(e);return new ve(t,(()=>URL.revokeObjectURL(t)))}}const we=l.getLogger("esri.geometry.support.meshUtils.offset");function be(e,t,n){e.vertexAttributes&&e.vertexAttributes.position&&(c(e.transform)?(null!=(null==n?void 0:n.geographic)&&n.geographic!==e.transform.geographic&&we.warn(`Specifying the 'geographic' parameter (${n.geographic}) different from the Mesh transform setting (${e.transform.geographic}) is not supported`),function(e,t){const n=e.origin;e.origin=b(u(),n,t)}(e.transform,t)):te(e.spatialReference,n)?function(e,t){const n=e.spatialReference,r=e.vertexAttributes.position,o=e.vertexAttributes.normal,s=e.vertexAttributes.tangent,i=new Float64Array(r.length),a=c(o)?new Float32Array(o.length):null,l=c(s)?new Float32Array(s.length):null,f=e.extent.center,u=Re;A(n,[f.x,f.y,f.z],Fe,R(n)),F(Me,Fe),M(u,t,Me),ae(r,n,i),c(o)&&le(o,r,i,n,a),c(s)&&ce(s,r,i,n,l),Ae(i,u),fe(i,r,n),c(o)&&ue(a,r,i,n,o),c(s)&&pe(l,r,i,n,s),e.vertexAttributesChanged()}(e,t):function(e,t){Ae(e.vertexAttributes.position,t),e.vertexAttributesChanged()}(e,t))}function Ae(e,t){if(e)for(let n=0;n<e.length;n+=3)for(let r=0;r<3;r++)e[n+r]+=t[r]}const Re=u(),Fe=O(),Me=j();const Oe={position:[-.5,-.5,0,.5,-.5,0,.5,.5,0,-.5,.5,0],normal:[0,0,1,0,0,1,0,0,1,0,0,1],uv:[0,1,1,1,1,0,0,0],faces:[0,1,2,0,2,3],facingAxisOrderSwap:{east:[3,1,2],west:[-3,-1,2],north:[-1,3,2],south:[1,-3,2],up:[1,2,3],down:[1,-2,-3]}};function je(e,r,o){(function(e){for(let t=0;t<e.position.length;t+=3)e.position[t+2]+=.5})(e),function(e,t){if(null==t)return;const n="number"==typeof t?[t,t,t]:[null!=t.width?t.width:1,null!=t.depth?t.depth:1,null!=t.height?t.height:1];Ce[0]=n[0],Ce[4]=n[1],Ce[8]=n[2];for(let r=0;r<e.position.length;r+=3){for(let t=0;t<3;t++)Le[t]=e.position[r+t];M(Le,Le,Ce);for(let t=0;t<3;t++)e.position[r+t]=Le[t]}if(n[0]!==n[1]||n[1]!==n[2]){Ce[0]=1/n[0],Ce[4]=1/n[1],Ce[8]=1/n[2];for(let t=0;t<e.normal.length;t+=3){for(let n=0;n<3;n++)Le[n]=e.normal[t+n];M(Le,Le,Ce),P(Le,Le);for(let n=0;n<3;n++)e.normal[t+n]=Le[n]}}}(e,o&&o.size);const{vertexAttributes:s,transform:i}=oe(e,r,o);return{vertexAttributes:new Q((l=a({},s),c={uv:e.uv},t(l,n(c)))),transform:i,components:[new K({faces:e.faces,material:o&&o.material||null})],spatialReference:r.spatialReference};var l,c}const Pe={faceDescriptions:[{axis:[0,-1,0],uvOrigin:[0,.625],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[1,0,0],uvOrigin:[.25,.625],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[0,1,0],uvOrigin:[.5,.625],corners:[[1,-1],[-1,-1],[-1,1],[1,1]]},{axis:[-1,0,0],uvOrigin:[.75,.625],corners:[[1,-1],[-1,-1],[-1,1],[1,1]]},{axis:[0,0,1],uvOrigin:[0,.375],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[0,0,-1],uvOrigin:[0,.875],corners:[[-1,1],[1,1],[1,-1],[-1,-1]]}],uvScales:[[0,0],[1,0],[1,1],[0,1]],faceVertexOffsets:[0,1,2,0,2,3]},ze={south:0,east:1,north:2,west:3,up:4,down:5},Le=u(),Ce=j(),Se=l.getLogger("esri.geometry.support.meshUtils.rotate");function ke(e,t,n){if(!e.vertexAttributes||!e.vertexAttributes.position||0===t[3])return;const r=e.spatialReference;if(c(e.transform)){var o;null!=(null==n?void 0:n.geographic)&&n.geographic!==e.transform.geographic&&Se.warn(`Specifying the 'geographic' parameter (${n.geographic}) different from the Mesh transform setting (${e.transform.geographic}) is not supported`);const s=null!=(o=null==n?void 0:n.origin)?o:e.transform.getOriginPoint(r);!function(e,t,n){const r=z($e,n.x,n.y,n.z),o=L($e,r,e.origin);e.applyLocalInverse(o,Ue),e.rotation=V(e.rotation,t,Y()),e.applyLocalInverse(o,o),L(o,o,Ue),e.translation=b(u(),e.translation,o)}(e.transform,t,s)}else{var s;const r=null!=(s=null==n?void 0:n.origin)?s:e.origin;te(e.spatialReference,n)?function(e,t,n){const r=e.spatialReference,o=R(r),s=De;f(n,s,o)||f(e.origin,s,o);const i=e.vertexAttributes.position,a=e.vertexAttributes.normal,l=e.vertexAttributes.tangent,u=new Float64Array(i.length),p=c(a)?new Float32Array(a.length):null,h=c(l)?new Float32Array(l.length):null;A(o,s,Te,o),F(Be,Te);const g=Ee;M(W(Ee),W(t),Be),g[3]=t[3],ae(i,r,u),c(a)&&le(a,i,u,r,p),c(l)&&ce(l,i,u,r,h),Ie(u,g,3,s),fe(u,i,r),c(a)&&(Ie(p,g,3),ue(p,i,u,r,a)),c(l)&&(Ie(h,g,4),pe(h,i,u,r,l)),e.vertexAttributesChanged()}(e,t,r):function(e,t,n){const r=De;if(!f(n,r,e.spatialReference)){const t=e.origin;r[0]=t.x,r[1]=t.y,r[2]=t.z,Se.error(`Failed to project specified origin (wkid:${n.spatialReference.wkid}) to mesh spatial reference (wkid:${e.spatialReference.wkid}).`)}Ie(e.vertexAttributes.position,t,3,r),Ie(e.vertexAttributes.normal,t,3),Ie(e.vertexAttributes.tangent,t,4),e.vertexAttributesChanged()}(e,t,r)}}function Ie(e,t,n,r=C){if(!v(e)){S(Te),k(Te,Te,_(t),W(t));for(let t=0;t<e.length;t+=n){for(let n=0;n<3;n++)$e[n]=e[t+n]-r[n];I($e,$e,Te);for(let n=0;n<3;n++)e[t+n]=$e[n]+r[n]}}}const $e=u(),Ue=u(),Ee=Y(),Te=O(),Be=j(),De=u(),Ge=l.getLogger("esri.geometry.support.meshUtils.scale");function Ze(e,t,n){if(!e.vertexAttributes||!e.vertexAttributes.position)return;const r=e.spatialReference;if(c(e.transform)){var o;null!=(null==n?void 0:n.geographic)&&n.geographic!==e.transform.geographic&&Ge.warn(`Specifying the 'geographic' parameter (${n.geographic}) different from the Mesh transform setting (${e.transform.geographic}) is not supported`);const s=null!=(o=null==n?void 0:n.origin)?o:e.transform.getOriginPoint(r);!function(e,t,n){const r=z(qe,n.x,n.y,n.z),o=L(qe,r,e.origin);e.applyLocalInverse(o,Je);const s=$(u(),e.scale,t);e.scale=s,e.applyLocalInverse(o,o),L(o,o,Je),e.translation=b(u(),e.translation,o)}(e.transform,t,s)}else{const r=te(e.spatialReference,n),o=n&&n.origin||e.origin;r?function(e,t,n){const r=e.spatialReference,o=R(r),s=Xe;f(n,s,o)||f(e.origin,s,o);const i=e.vertexAttributes.position,a=e.vertexAttributes.normal,l=e.vertexAttributes.tangent,u=new Float64Array(i.length),p=c(a)?new Float32Array(a.length):null,h=c(l)?new Float32Array(l.length):null;ae(i,r,u),c(a)&&le(a,i,u,r,p),c(l)&&ce(l,i,u,r,h),Ne(u,t,s),fe(u,i,r),c(a)&&ue(p,i,u,r,a),c(l)&&pe(h,i,u,r,l),e.vertexAttributesChanged()}(e,t,o):function(e,t,n){const r=Xe;if(!f(n,r,e.spatialReference)){const t=e.origin;r[0]=t.x,r[1]=t.y,r[2]=t.z,Ge.error(`Failed to project specified origin (wkid:${n.spatialReference.wkid}) to mesh spatial reference (wkid:${e.spatialReference.wkid}).`)}Ne(e.vertexAttributes.position,t,r),e.vertexAttributesChanged()}(e,t,o)}}function Ne(e,t,n=C){if(e)for(let r=0;r<e.length;r+=3){for(let t=0;t<3;t++)qe[t]=e[r+t]-n[t];$(qe,qe,t);for(let t=0;t<3;t++)e[r+t]=qe[t]+n[t]}}const qe=u(),Je=u(),Xe=u();var Ye;const Ve=l.getLogger("esri.geometry.Mesh");let We=Ye=class extends(U.LoadableMixin(E(T))){constructor(e){super(e),this.components=null,this.transform=null,this.external=null,this.hasZ=!0,this.hasM=!1,this.vertexAttributes=new ee,this.type="mesh"}initialize(){(v(this.external)||this.vertexAttributes.position.length)&&(this.loadStatus="loaded")}get hasExtent(){return!this.loaded&&c(this.external)&&c(this.external.extent)||this.loaded&&this.vertexAttributes.position.length>0&&(!this.components||this.components.length>0)}get boundingInfo(){const e=this.vertexAttributes.position,t=this.spatialReference;if(0===e.length||this.components&&0===this.components.length)return{extent:new B({xmin:0,ymin:0,zmin:0,xmax:0,ymax:0,zmax:0,spatialReference:t}),center:new h({x:0,y:0,z:0,spatialReference:t})};const n=c(this.transform)?this.transform.project(e,t):e;let r=1/0,o=1/0,s=1/0,i=-1/0,a=-1/0,l=-1/0,f=0,u=0,p=0;const g=n.length,m=1/(g/3);let d=0;for(;d<g;){const e=n[d++],t=n[d++],c=n[d++];r=Math.min(r,e),o=Math.min(o,t),s=Math.min(s,c),i=Math.max(i,e),a=Math.max(a,t),l=Math.max(l,c),f+=m*e,u+=m*t,p+=m*c}return{extent:new B({xmin:r,ymin:o,zmin:s,xmax:i,ymax:a,zmax:l,spatialReference:t}),center:new h({x:f,y:u,z:p,spatialReference:t})}}get anchor(){if(c(this.transform))return this.transform.getOriginPoint(this.spatialReference);const e=this.boundingInfo;return new h({x:e.center.x,y:e.center.y,z:e.extent.zmin,spatialReference:this.spatialReference})}get origin(){return c(this.transform)?this.transform.getOriginPoint(this.spatialReference):this.boundingInfo.center}get extent(){return!this.loaded&&c(this.external)&&c(this.external.extent)?this.external.extent.clone():this.boundingInfo.extent}addComponent(e){this.loaded?(this.components||(this.components=[]),this.components.push(K.from(e)),this.notifyChange("components")):Ve.error("addComponent()","Mesh must be loaded before applying operations")}removeComponent(e){if(this.loaded){if(this.components){const t=this.components.indexOf(e);if(-1!==t)return this.components.splice(t,1),void this.notifyChange("components")}Ve.error("removeComponent()","Provided component is not part of the list of components")}else Ve.error("removeComponent()","Mesh must be loaded before applying operations")}rotate(e,t,n,r){return H(_e.x,e,He),H(_e.y,t,Qe),H(_e.z,n,Ke),V(He,Qe,He),V(He,Ke,He),ke(this,He,r),this}offset(e,t,n,r){return this.loaded?(et[0]=e,et[1]=t,et[2]=n,be(this,et,r),this):(Ve.error("offset()","Mesh must be loaded before applying operations"),this)}scale(e,t){return this.loaded?(Ze(this,e,t),this):(Ve.error("scale()","Mesh must be loaded before applying operations"),this)}centerAt(e,t){return this.loaded?(ge(this,e,t),this):(Ve.error("centerAt()","Mesh must be loaded before applying operations"),this)}load(e){return c(this.external)&&this.addResolvingPromise(async function(e,t,n){const{loadGLTFMesh:r}=await p(import("./loadGLTFMesh.8b382c52.js"),n),o=await ye(t,n),s=r(new h({x:0,y:0,z:0,spatialReference:e.spatialReference}),o.url,{resolveFile:xe(o),useTransform:!0,signal:c(n)?n.signal:null});s.then((()=>o.dispose()),(()=>o.dispose()));const{vertexAttributes:i,components:a}=await s;e.vertexAttributes=i,e.components=a}(this,this.external.source,e)),Promise.resolve(this)}clone(){const e=this.components?new Map:null,t=this.components?new Map:null,n={components:this.components?this.components.map((n=>n.cloneWithDeduplication(e,t))):null,spatialReference:this.spatialReference,vertexAttributes:this.vertexAttributes.clone(),transform:c(this.transform)?this.transform.clone():null,external:c(this.external)?{source:this.external.source,extent:c(this.external.extent)?this.external.extent.clone():null}:null};return new Ye(n)}vertexAttributesChanged(){this.notifyChange("vertexAttributes")}async toBinaryGLTF(e){const{toBinaryGLTF:t}=await import("./gltfexport.1e264199.js");return t(this,e)}static createBox(e,t){if(!(e instanceof h))return Ve.error(".createBox()","expected location to be a Point instance"),null;const n=new Ye(je(function(){const{faceDescriptions:e,faceVertexOffsets:t,uvScales:n}=Pe,r=4*e.length,o=new Float64Array(3*r),s=new Float32Array(3*r),i=new Float32Array(2*r),a=new Uint32Array(2*e.length*3);let l=0,c=0,f=0,u=0;for(let p=0;p<e.length;p++){const r=e[p],h=l/3;for(const e of t)a[u++]=h+e;const g=r.corners;for(let e=0;e<4;e++){const t=g[e];let a=0;i[f++]=.25*n[e][0]+r.uvOrigin[0],i[f++]=r.uvOrigin[1]-.25*n[e][1];for(let e=0;e<3;e++)0!==r.axis[e]?(o[l++]=.5*r.axis[e],s[c++]=r.axis[e]):(o[l++]=.5*t[a++],s[c++]=0)}}return{position:o,normal:s,uv:i,faces:a}}(),e,t));return t&&t.imageFace&&"all"!==t.imageFace?function(e,t){const n=e.components[0],r=n.faces,o=ze[t],s=6*o,i=new Uint32Array(6),a=new Uint32Array(r.length-6);let l=0,f=0;for(let c=0;c<r.length;c++)c>=s&&c<s+6?i[l++]=r[c]:a[f++]=r[c];if(c(e.vertexAttributes.uv)){const t=new Float32Array(e.vertexAttributes.uv),n=4*o*2,r=[0,1,1,1,1,0,0,0];for(let e=0;e<r.length;e++)t[n+e]=r[e];e.vertexAttributes.uv=t}return e.components=[new K({faces:i,material:n.material}),new K({faces:a})],e}(n,t.imageFace):n}static createSphere(e,t){return e instanceof h?new Ye(je(function(e=0){const t=Math.round(8*2**e),n=2*t,r=(t-1)*(n+1)+2*n,o=new Float64Array(3*r),s=new Float32Array(3*r),i=new Float32Array(2*r),a=new Uint32Array((t-1)*n*2*3);let l=0,c=0,f=0,u=0;for(let p=0;p<=t;p++){const e=p/t*Math.PI+.5*Math.PI,r=Math.cos(e),h=Math.sin(e);Le[2]=h;const g=0===p||p===t,m=g?n-1:n;for(let d=0;d<=m;d++){const e=d/m*2*Math.PI;Le[0]=-Math.sin(e)*r,Le[1]=Math.cos(e)*r;for(let t=0;t<3;t++)o[l]=.5*Le[t],s[l]=Le[t],++l;i[c++]=(d+(g?.5:0))/n,i[c++]=p/t,0!==p&&d!==n&&(p!==t&&(a[f++]=u,a[f++]=u+1,a[f++]=u-n),1!==p&&(a[f++]=u,a[f++]=u-n,a[f++]=u-n-1)),u++}}return{position:o,normal:s,uv:i,faces:a}}(t&&t.densificationFactor||0),e,t)):(Ve.error(".createSphere()","expected location to be a Point instance"),null)}static createCylinder(e,t){return e instanceof h?new Ye(je(function(e=0){const t=Math.round(16*2**e),n=4*(t+1)+2*t,r=new Float64Array(3*n),o=new Float32Array(3*n),s=new Float32Array(2*n),i=new Uint32Array(4*t*3);let a=0,l=0,c=0,f=0,u=0;for(let p=0;p<=5;p++){const e=0===p||5===p,n=p<=1||p>=4,h=2===p||4===p,g=e?t-1:t;for(let m=0;m<=g;m++){const d=m/g*2*Math.PI,x=e?0:.5;Le[0]=x*Math.sin(d),Le[1]=x*-Math.cos(d),Le[2]=p<=2?.5:-.5;for(let e=0;e<3;e++)r[a++]=Le[e],o[l++]=n?2===e?p<=1?1:-1:0:2===e?0:Le[e]/x;s[c++]=(m+(e?.5:0))/t,s[c++]=p<=1?1*p/3:p<=3?1*(p-2)/3+1/3:1*(p-4)/3+2/3,h||0===p||m===t||(5!==p&&(i[f++]=u,i[f++]=u+1,i[f++]=u-t),1!==p&&(i[f++]=u,i[f++]=u-t,i[f++]=u-t-1)),u++}}return{position:r,normal:o,uv:s,faces:i}}(t&&t.densificationFactor||0),e,t)):(Ve.error(".createCylinder()","expected location to be a Point instance"),null)}static createPlane(e,t){return e instanceof h?new Ye(je(function(e){const t=Oe.facingAxisOrderSwap[e],n=Oe.position,r=Oe.normal,o=new Float64Array(n.length),s=new Float32Array(r.length);let i=0;for(let a=0;a<4;a++){const e=i;for(let a=0;a<3;a++){const l=t[a],c=Math.abs(l)-1,f=l>=0?1:-1;o[i]=n[e+c]*f,s[i]=r[e+c]*f,i++}}return{position:o,normal:s,uv:new Float32Array(Oe.uv),faces:new Uint32Array(Oe.faces)}}(t&&t.facing||"up"),e,t)):(Ve.error(".createPlane()","expected location to be a Point instance"),null)}static createFromPolygon(e,t){if(!(e instanceof D))return Ve.error(".createFromPolygon()","expected polygon to be a Polygon instance"),null;const n=ie(e);return new Ye({vertexAttributes:new ee({position:n.position}),components:[new K({faces:n.faces,shading:"flat",material:t&&t.material||null})],spatialReference:e.spatialReference})}static async createFromGLTF(e,t,n){if(!(e instanceof h))throw Ve.error(".createfromGLTF()","expected location to be a Point instance"),new w("invalid-input","Expected location to be a Point instance");const{loadGLTFMesh:r}=await p(import("./loadGLTFMesh.8b382c52.js"),n);return new Ye(await r(e,t,n))}static createWithExternalSource(e,t,n){var r,o,s;const i=null!=(r=null==n?void 0:n.extent)?r:null,a=null!=(o=null==n?void 0:n.transform.clone())?o:new se;a.origin=[e.x,e.y,null!=(s=e.z)?s:0];const l=e.spatialReference;return new Ye({external:{source:t,extent:i},transform:a,spatialReference:l})}static createIncomplete(e,t){var n,r;const o=null!=(n=null==t?void 0:t.transform.clone())?n:new se;o.origin=[e.x,e.y,null!=(r=e.z)?r:0];const s=e.spatialReference,i=new Ye({transform:o,spatialReference:s});return i.addResolvingPromise(Promise.reject(new w("mesh-incomplete","Mesh resources are not complete"))),i}};G([Z({type:[K],json:{write:!0}})],We.prototype,"components",void 0),G([Z({type:se,json:{write:!0}})],We.prototype,"transform",void 0),G([Z({constructOnly:!0})],We.prototype,"external",void 0),G([Z({readOnly:!0})],We.prototype,"hasExtent",null),G([Z({readOnly:!0})],We.prototype,"boundingInfo",null),G([Z({readOnly:!0})],We.prototype,"anchor",null),G([Z({readOnly:!0})],We.prototype,"origin",null),G([Z({readOnly:!0,json:{read:!1}})],We.prototype,"extent",null),G([Z({readOnly:!0,json:{read:!1,write:!0,default:!0}})],We.prototype,"hasZ",void 0),G([Z({readOnly:!0,json:{read:!1,write:!0,default:!1}})],We.prototype,"hasM",void 0),G([Z({type:ee,nonNullable:!0,json:{write:!0}})],We.prototype,"vertexAttributes",void 0),We=Ye=G([N("esri.geometry.Mesh")],We);const _e={x:q(1,0,0),y:q(0,1,0),z:q(0,0,1)},He=Y(),Qe=Y(),Ke=Y(),et=u();var tt=We;function nt(e,t,n){const r=n.features;n.features=[],delete n.geometryType;const o=J.fromJSON(n);o.geometryType="mesh";const s=o.spatialReference,i=v(e.outFields)||!e.outFields.length?()=>({}):(a=e.outFields.includes("*")?null:new Set(e.outFields),({attributes:e})=>{if(!e)return{};if(!a)return e;for(const t in e)a.has(t)||delete e[t];return e});var a;for(const l of r){const e=rt(l,s,t);c(e)&&o.features.push(new X({geometry:e,attributes:i(l)}))}return o}function rt(e,t,n){const{status:r,source:o}=function(e){if(!e.assetMappings)return{status:0};const t=[],n=new Map;for(const r of e.assetMappings){const e=r.seqNo,o=r.assetName,s=r.assetURL,i=r.conversionStatus;if("FAILED"===i)return{status:0};if("COMPLETED"!==i)return{status:1};if(null==e)t.push({name:o,source:s});else{const r=n.get(o);let i;r?i=r.multipart:(i=[],t.push({name:o,source:{multipart:i}}),n.set(o,{multipart:i})),i[e]=s}}return{status:2,source:t}}(e);if(0===r)return null;const s=function({attributes:e},t,{transformFieldRoles:n}){return new h({x:e[n.originX],y:e[n.originY],z:e[n.originZ],spatialReference:t})}(e,t,n),i=B.fromJSON(e.geometry);i.spatialReference=t;const a=function({attributes:e,assetMappings:t},{transformFieldRoles:n}){var r;return new se({translation:[e[n.translationX],e[n.translationY],e[n.translationZ]],rotation:H([e[n.rotationX],e[n.rotationY],e[n.rotationZ]],e[n.rotationDeg]),scale:[e[n.scaleX],e[n.scaleY],e[n.scaleZ]],geographic:!(null!=(r=t.flags)&&r.includes("PROJECT_VERTICES"))})}(e,n);return 1===r?tt.createIncomplete(s,{extent:i,transform:a}):tt.createWithExternalSource(s,o,{extent:i,transform:a})}export{nt as meshFeatureSetFromJSON};
