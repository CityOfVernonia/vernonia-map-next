import{an as i,f_ as n,b$ as s,ie as t,fZ as a,ht as e,ge as o,bU as r,ig as c,ih as u,ii as g,bX as b,hj as l,fW as f,f0 as p,bV as d,ij as h,ik as I,g9 as m,il as N,bW as P,im as w,hk as M,io as A,gU as T,ip as _,hx as v,iq as V,fY as x,ir as j,is as y,gb as E,it as S,gA as O,cN as U,ga as Y,iu as k,h1 as q,gu as F,fA as B,hl as C,f$ as R}from"./vendor.c9efa5f2.js";const W=i.getLogger("esri.views.3d.support.geometryUtils.boundedPlane");function L(i=ci){return{plane:n(i.plane),origin:e(i.origin),basis1:e(i.basis1),basis2:e(i.basis2)}}function $(i,n=L()){return z(i.origin,i.basis1,i.basis2,n)}function z(i,n,s,t=L()){return o(t.origin,i),o(t.basis1,n),o(t.basis2,s),G(t),function(i,n){Math.abs(T(i.basis1,i.basis2)/(P(i.basis1)*P(i.basis2)))>1e-6&&W.warn(n,"Provided basis vectors are not perpendicular"),Math.abs(T(i.basis1,ti(i)))>1e-6&&W.warn(n,"Basis vectors and plane normal are not perpendicular"),Math.abs(-T(ti(i),i.origin)-i.plane[3])>1e-6&&W.warn(n,"Plane offset is not consistent with plane origin")}(t,"fromValues()"),t}function G(i){g(i.basis2,i.basis1,i.origin,i.plane)}function X(i,n,s){i!==s&&$(i,s);const t=b(f.get(),ti(i),n);return p(s.origin,s.origin,t),s.plane[3]-=n,s}function Z(i,n=L()){const s=(i[2]-i[0])/2,t=(i[3]-i[1])/2;return d(n.origin,i[0]+s,i[1]+t,0),d(n.basis1,s,0,0),d(n.basis2,0,t,0),h(0,0,1,0,n.plane),n}function D(i,n,s){return!!m(i.plane,n,s)&&ai(i,s)}function H(i,n,s){const t=ui.get();ri(i,n,t,ui.get());let a=Number.POSITIVE_INFINITY;for(const e of fi){const r=oi(i,e,gi.get()),c=f.get();if(w(t,r,c)){const i=M(f.get(),n.origin,c),t=Math.abs(A(T(n.direction,i)));t<a&&(a=t,o(s,c))}}return a===Number.POSITIVE_INFINITY?J(i,n,s):s}function J(i,n,s){if(D(i,n,s))return s;const t=ui.get(),a=ui.get();ri(i,n,t,a);let e=Number.POSITIVE_INFINITY;for(const r of fi){const c=oi(i,r,gi.get()),u=f.get();if(_(t,c,u)){const i=v(n,u);if(!V(a,u))continue;i<e&&(e=i,o(s,u))}}return ii(i,n.origin)<e&&K(i,n.origin,s),s}function K(i,n,s){const t=j(i.plane,n,f.get()),a=y(ei(i,i.basis1),t,-1,1,f.get()),e=y(ei(i,i.basis2),t,-1,1,f.get());return x(s,p(f.get(),a,e),i.origin),s}function Q(i,n,s){const{origin:t,basis1:a,basis2:e}=i,o=x(f.get(),n,t),r=I(a,o),c=I(e,o),u=I(ti(i),o);return d(s,r,c,u)}function ii(i,n){const s=Q(i,n,f.get()),{basis1:t,basis2:a}=i,e=P(t),o=P(a),r=Math.max(Math.abs(s[0])-e,0),c=Math.max(Math.abs(s[1])-o,0),u=s[2];return r*r+c*c+u*u}function ni(i,n){return Math.sqrt(ii(i,n))}function si(i,n){const s=-i.plane[3];return I(ti(i),n)-s}function ti(i){return l(i.plane)}function ai(i,n){const s=x(f.get(),n,i.origin),t=C(i.basis1),a=C(i.basis2),e=T(i.basis1,s),o=T(i.basis2,s);return-e-t<0&&e-t<0&&-o-a<0&&o-a<0}function ei(i,n){const s=gi.get();return o(s.origin,i.origin),o(s.vector,n),s}function oi(i,n,s){const{basis1:t,basis2:a,origin:e}=i,o=b(f.get(),t,n.origin[0]),r=b(f.get(),a,n.origin[1]);p(s.origin,o,r),p(s.origin,s.origin,e);const c=b(f.get(),t,n.direction[0]),u=b(f.get(),a,n.direction[1]);return b(s.vector,p(c,c,u),2),s}function ri(i,n,s,t){const a=ti(i);g(a,n.direction,n.origin,s),g(l(s),a,n.origin,t)}const ci={plane:n(),origin:s(0,0,0),basis1:s(1,0,0),basis2:s(0,1,0)},ui=new t(n),gi=new t(a),bi=r(),li=new t((()=>({origin:null,basis1:null,basis2:null,plane:null}))),fi=[{origin:[-1,-1],direction:[1,0]},{origin:[1,-1],direction:[0,1]},{origin:[1,1],direction:[-1,0]},{origin:[-1,1],direction:[0,-1]}],pi=R(),di=R();Object.freeze({__proto__:null,BoundedPlaneClass:class{constructor(){this.plane=n(),this.origin=r(),this.basis1=r(),this.basis2=r()}},create:L,wrap:function(i,n,s){const t=li.get();return t.origin=i,t.basis1=n,t.basis2=s,t.plane=c(0,0,0,0),G(t),t},copy:$,copyWithoutVerify:function(i,n){o(n.origin,i.origin),o(n.basis1,i.basis1),o(n.basis2,i.basis2),u(i.plane,n.plane)},fromValues:z,updateUnboundedPlane:G,elevate:X,setExtent:function(i,n,s){return Z(n,s),X(s,si(i,i.origin),s),s},fromAABoundingRect:Z,intersectRay:D,intersectRayClosestSilhouette:function(i,n,s){if(D(i,n,s))return s;const t=H(i,n,f.get());return p(s,n.origin,b(f.get(),n.direction,N(n.origin,t)/P(n.direction))),s},closestPointOnSilhouette:H,closestPoint:J,projectPoint:K,projectPointLocal:Q,distance2:ii,distance:ni,distanceToSilhouette:function(i,n){let s=Number.NEGATIVE_INFINITY;for(const t of fi){const a=oi(i,t,gi.get()),e=E(a,n);e>s&&(s=e)}return Math.sqrt(s)},extrusionContainsPoint:function(i,n){return V(i.plane,n)&&ai(i,n)},axisAt:function(i,n,s,t){return function(i,n,s){switch(n){case 0:o(s,i.basis1),B(s,s);break;case 1:o(s,i.basis2),B(s,s);break;case 2:o(s,ti(i))}return s}(i,s,t)},altitudeAt:si,setAltitudeAt:function(i,n,s,t){const a=si(i,n),e=b(bi,ti(i),s-a);return p(t,n,e),t},equals:function(i,n){return S(i.basis1,n.basis1)&&S(i.basis2,n.basis2)&&S(i.origin,n.origin)},transform:function(i,n,s){return i!==s&&$(i,s),O(pi,n),U(pi,pi),Y(s.basis1,i.basis1,pi),Y(s.basis2,i.basis2,pi),Y(l(s.plane),l(i.plane),pi),Y(s.origin,i.origin,n),k(s.plane,s.origin,s.plane),s},rotate:function(i,n,s,t){return i!==t&&$(i,t),q(di,F(di),n,s),Y(t.basis1,i.basis1,di),Y(t.basis2,i.basis2,di),G(t),t},normal:ti,UP:ci});export{$ as D,L as G,G as K,Z,ni as o};
