var e=Object.defineProperty,t=Object.defineProperties,i=Object.getOwnPropertyDescriptors,s=Object.getOwnPropertySymbols,r=Object.prototype.hasOwnProperty,n=Object.prototype.propertyIsEnumerable,a=(t,i,s)=>i in t?e(t,i,{enumerable:!0,configurable:!0,writable:!0,value:s}):t[i]=s,o=(e,t)=>{for(var i in t||(t={}))r.call(t,i)&&a(e,i,t[i]);if(s)for(var i of s(t))n.call(t,i)&&a(e,i,t[i]);return e},l=(e,s)=>t(e,i(s));import{ae as d,oq as u,a as p,pe as y,pf as c,dU as f,d3 as m,df as h,dK as g,aJ as b,dH as j,dJ as I,pg as F}from"./vendor.9770a310.js";import{u as _}from"./FeatureStore.3f0ef149.js";import{y as E,p as T}from"./projectionSupport.12e8a92c.js";import{H as q}from"./QueryEngine.1ed35f1d.js";import{I as x,T as w,k as O}from"./geojson.54da8a71.js";import{u as D,i as R,n as S}from"./clientSideDefaults.1628d670.js";import{y as Q,d as v,c as k,u as P,h as C}from"./sourceUtils.807b7275.js";import"./PooledRBush.0543bc18.js";import"./quickselect.c0fda8e0.js";import"./optimizedFeatureQueryEngineAdapter.32b8979d.js";import"./centroid.f7592ee4.js";import"./json.df9e51f4.js";import"./WhereClause.4ea114a9.js";import"./QueryEngineCapabilities.54eb86f4.js";import"./utils.13f35172.js";import"./spatialQuerySupport.2891a9d3.js";const A={hasAttachments:!1,capabilities:"query, editing, create, delete, update",useStandardizedQueries:!0,supportsCoordinatesQuantization:!0,supportsReturningQueryGeometry:!0,advancedQueryCapabilities:{supportsQueryAttachments:!1,supportsStatistics:!0,supportsPercentileStatistics:!0,supportsReturningGeometryCentroid:!0,supportsQueryWithDistance:!0,supportsDistinct:!0,supportsReturningQueryExtent:!0,supportsReturningGeometryProperties:!1,supportsHavingClause:!0,supportsOrderBy:!0,supportsPagination:!0,supportsQueryWithResultType:!1,supportsSqlExpression:!0,supportsDisjointSpatialRel:!0}};class Z{constructor(){this._queryEngine=null}destroy(){this._queryEngine&&this._queryEngine&&this._queryEngine.destroy(),this._queryEngine=this._requiredFields=this._fieldsIndex=this._createDefaultAttributes=null}async load(e){const t=[];await this._checkProjection(e.spatialReference);let i=null;e.url&&(i=(await d(e.url,{responseType:"json"})).data,await x(i));const s=w(i,{geometryType:e.geometryType}),r=e.fields||s.fields||[],n=null!=e.hasZ?e.hasZ:s.hasZ,a=s.geometryType,b=e.objectIdField||("number"===s.objectIdFieldType?s.objectIdFieldName:"OBJECTID")||"OBJECTID",j=e.spatialReference||u;let I=e.timeInfo;if(!a)throw new p("geojson-layer:missing-property","geometryType not set and couldn't be inferred from the provided features");if("string"===s.objectIdFieldType&&t.push({name:"geojson-layer:unsupported-id-type",message:"Feature ids are of type string and can't be honored."}),r===s.fields&&s.unknownFields.length>0&&t.push({name:"geojson-layer:unknown-field-types",message:"Some fields types couldn't be inferred from the features and were dropped",details:{unknownFields:s.unknownFields}}),b){let e=null;r.some((t=>t.name===b&&(e=t,!0)))?(e.type="esriFieldTypeOID",e.editable=!1,e.nullable=!1):r.unshift({alias:b,name:b,type:"esriFieldTypeOID",editable:!1,nullable:!1})}for(const o of r){if(null==o.name&&(o.name=o.alias),null==o.alias&&(o.alias=o.name),!o.name)throw new p("geojson-layer:invalid-field-name","field name is missing",{field:o});if(o.name===b&&(o.type="esriFieldTypeOID"),-1===y.jsonValues.indexOf(o.type))throw new p("geojson-layer:invalid-field-type",`invalid type for field "${o.name}"`,{field:o})}const F={};this._requiredFields=[];for(const o of r)if("esriFieldTypeOID"!==o.type&&"esriFieldTypeGlobalID"!==o.type){o.editable=null==o.editable||!!o.editable,o.nullable=null==o.nullable||!!o.nullable;const e=c(o);o.nullable||void 0!==e?F[o.name]=e:this._requiredFields.push(o)}if(this._fieldsIndex=new f(r),I){if(I.startTimeField){const e=this._fieldsIndex.get(I.startTimeField);e?(I.startTimeField=e.name,e.type="esriFieldTypeDate"):I.startTimeField=null}if(I.endTimeField){const e=this._fieldsIndex.get(I.endTimeField);e?(I.endTimeField=e.name,e.type="esriFieldTypeDate"):I.endTimeField=null}if(I.trackIdField){const e=this._fieldsIndex.get(I.trackIdField);e?I.trackIdField=e.name:(I.trackIdField=null,t.push({name:"geojson-layer:invalid-timeInfo-trackIdField",message:"trackIdField is missing",details:{timeInfo:I}}))}I.startTimeField||I.endTimeField||(t.push({name:"geojson-layer:invalid-timeInfo",message:"startTimeField and endTimeField are missing",details:{timeInfo:I}}),I=null)}const T={warnings:t,featureErrors:[],layerDefinition:l(o({},A),{drawingInfo:D(a),templates:R(F),extent:null,geometryType:a,objectIdField:b,fields:r,hasZ:!!n,timeInfo:I})};this._queryEngine=new q({fields:r,geometryType:a,hasM:!1,hasZ:n,objectIdField:b,spatialReference:j,timeInfo:I,featureStore:new _({geometryType:a,hasM:!1,hasZ:n}),cacheSpatialQueries:!0}),this._createDefaultAttributes=S(F,b),this._nextObjectId=s.maxObjectId+1;const Q=O(i,{geometryType:a,hasZ:n,objectIdField:"number"===s.objectIdFieldType?b:null});if(!m(j,u))for(const o of Q)o.geometry&&(o.geometry=h(E(g(o.geometry,a,n,!1),u,j)));return this._loadInitialFeatures(T,Q),T}async applyEdits(e){const{spatialReference:t,geometryType:i}=this._queryEngine;return await Promise.all([Q(t,i),T(e.adds,t),T(e.updates,t)]),this._applyEdits(e)}queryFeatures(e={},t={}){return this._queryEngine.executeQuery(e,t.signal)}queryFeatureCount(e={},t={}){return this._queryEngine.executeQueryForCount(e,t.signal)}queryObjectIds(e={},t={}){return this._queryEngine.executeQueryForIds(e,t.signal)}queryExtent(e={},t={}){return this._queryEngine.executeQueryForExtent(e,t.signal)}querySnapping(e,t={}){return this._queryEngine.executeQueryForSnapping(e,t.signal)}_loadInitialFeatures(e,t){const{featureStore:i,objectIdField:s}=this._queryEngine,r=[];for(const n of t){const t=this._createDefaultAttributes(),i=v(this._fieldsIndex,t,n.attributes,this._requiredFields,!0,e.warnings);i?e.featureErrors.push(i):(this._assignObjectId(t,n.attributes,!0),n.attributes=t,n.objectId=t[s],r.push(n))}if(i.addMany(r),e.layerDefinition.extent=this._queryEngine.fullExtent,e.layerDefinition.timeInfo){const{start:t,end:i}=this._queryEngine.timeExtent;e.layerDefinition.timeInfo.timeExtent=[t,i]}return e}_applyEdits(e){const{adds:t,updates:i,deletes:s}=e,r={addResults:[],deleteResults:[],updateResults:[],uidToObjectId:{}};if(t&&t.length&&this._applyAddEdits(r,t),i&&i.length&&this._applyUpdateEdits(r,i),s&&s.length){for(const e of s)r.deleteResults.push(k(e));this._queryEngine.featureStore.removeManyById(s)}return{fullExtent:this._queryEngine.fullExtent,timeExtent:this._queryEngine.timeExtent,featureEditResults:r}}_applyAddEdits(e,t){const{addResults:i}=e,{geometryType:s,hasM:r,hasZ:n,objectIdField:a,spatialReference:o,featureStore:l}=this._queryEngine,d=[];for(const u of t){if(u.geometry&&s!==b(u.geometry)){i.push(P("Incorrect geometry type."));continue}const t=this._createDefaultAttributes(),r=v(this._fieldsIndex,t,u.attributes,this._requiredFields);if(r)i.push(r);else{if(this._assignObjectId(t,u.attributes),u.attributes=t,null!=u.uid){const t=u.attributes[a];e.uidToObjectId[u.uid]=t}u.geometry&&(u.geometry=E(C(u.geometry,o),u.geometry.spatialReference,o)),d.push(u),i.push(k(u.attributes[a]))}}l.addMany(j([],d,s,n,r,a))}_applyUpdateEdits({updateResults:e},t){const{geometryType:i,hasM:s,hasZ:r,objectIdField:n,spatialReference:a,featureStore:o}=this._queryEngine;for(const l of t){const{attributes:t,geometry:d}=l,u=t&&t[n];if(null==u){e.push(P(`Identifier field ${n} missing`));continue}if(!o.has(u)){e.push(P(`Feature with object id ${u} missing`));continue}const p=I(o.getFeature(u),i,r,s);if(d){if(i!==b(d)){e.push(P("Incorrect geometry type."));continue}p.geometry=E(C(d,a),d.spatialReference,a)}if(t){const i=v(this._fieldsIndex,p.attributes,t,this._requiredFields);if(i){e.push(i);continue}}o.add(F(p,i,r,s,n)),e.push(k(u))}}_assignObjectId(e,t,i=!1){const s=this._queryEngine.objectIdField;i&&isFinite(t[s])?e[s]=t[s]:e[s]=this._nextObjectId++}async _checkProjection(e){try{await T(u,e)}catch{throw new p("geojson-layer","Projection not supported")}}}export{Z as default};
