import{a3 as t,y as n,n as r,a5 as e,bU as o,b$ as a,h5 as i,h1 as s,h3 as l,gA as c,f$ as p,ga as u,kV as g,oY as f,gq as h,jZ as y,gp as m,f5 as A,oZ as v,hp as x,v as w,a8 as T,it as d,o_ as F,ht as M,kT as R,be as b,fI as E,mR as j,cs as N,lW as z,o$ as _,gv as L}from"./vendor.c9efa5f2.js";import{a as P,v as B,x as I}from"./axisAngleDegrees.f2f09ac8.js";import{e as O,a as Y,f as k}from"./vec33.e99e2659.js";import{M as q,_ as G,R as S,v as $,F as V,B as W,V as Z,k as D,L as U}from"./projection.8026eb34.js";var C;let H=C=class extends e{constructor(t){super(t),this.origin=o(),this.translation=o(),this.rotation=P(),this.scale=a(1,1,1),this.geographic=!0}get localMatrix(){const t=p();return i(t,t,this.scale),s(t,t,I(this.rotation),B(this.rotation)),l(t,t,this.translation),t}get localMatrixInverse(){return c(p(),this.localMatrix)}applyLocal(t,n){return u(n,t,this.localMatrix)}applyLocalInverse(t,n){return u(n,t,this.localMatrixInverse)}project(t,n){const r=new Float64Array(t.length),e=g.fromTypedArray(r),o=g.fromTypedArray(t);if(this.geographic){const t=f(h(n)),a=p();return y(n,this.origin,a,t),m(a,a,this.localMatrix),O(e,o,a),A(r,t,0,r,n,0,r.length/3),r}const{localMatrix:a,origin:i}=this;v(a,x)?Y(e,o):O(e,o,a);for(let s=0;s<r.length;s+=3)r[s+0]+=i[0],r[s+1]+=i[1],r[s+2]+=i[2];return r}getOriginPoint(t){const[n,r,e]=this.origin;return new w({x:n,y:r,z:e,spatialReference:t})}equals(t){return T(t)&&this.geographic===t.geographic&&d(this.origin,t.origin)&&F(this.localMatrix,t.localMatrix)}clone(){const t={origin:M(this.origin),translation:M(this.translation),rotation:P(this.rotation),scale:M(this.scale),geographic:this.geographic};return new C(t)}};t([n({type:[Number],nonNullable:!0,json:{write:!0}})],H.prototype,"origin",void 0),t([n({type:[Number],nonNullable:!0,json:{write:!0}})],H.prototype,"translation",void 0),t([n({type:[Number],nonNullable:!0,json:{write:!0}})],H.prototype,"rotation",void 0),t([n({type:[Number],nonNullable:!0,json:{write:!0}})],H.prototype,"scale",void 0),t([n({type:Boolean,nonNullable:!0,json:{write:!0}})],H.prototype,"geographic",void 0),t([n()],H.prototype,"localMatrix",null),t([n()],H.prototype,"localMatrixInverse",null),H=C=t([r("esri.geometry.support.MeshTransform")],H);var J=H;function K(t,n){var r;return t.isGeographic||t.isWebMercator&&(null==(r=null==n?void 0:n.geographic)||r)}function Q(t,n,r){return K(n.spatialReference,r)?function(t,n,r){const e=n.spatialReference,o=st(n,r,ut),a=new Float64Array(t.position.length),i=function(t,n,r,e){O(g.fromTypedArray(e),g.fromTypedArray(t),n);const o=new Float64Array(t.length);return q(e,o,r)}(t.position,o,e,a),s=R(ft,o);return{position:i,normal:et(i,a,t.normal,s,e),tangent:ot(i,a,t.tangent,s,e)}}(t,n,r):function(t,n,r){const e=new Float64Array(t.position.length),o=t.position,a=n.x,i=n.y,s=n.z||0,{horizontal:l,vertical:c}=pt(r?r.unit:null,n.spatialReference);for(let p=0;p<o.length;p+=3)e[p+0]=o[p+0]*l+a,e[p+1]=o[p+1]*l+i,e[p+2]=o[p+2]*c+s;return{position:e,normal:t.normal,tangent:t.tangent}}(t,n,r)}function X(t,n,r){const{position:e,normal:o,tangent:a}=t;if(b(n))return{position:e,normal:o,tangent:a};const i=n.localMatrix;return Q({position:Z(e,new Float64Array(e.length),i),normal:T(o)?D(o,new Float32Array(o.length),i):null,tangent:T(a)?U(a,new Float32Array(a.length),i):null},n.getOriginPoint(r),{geographic:n.geographic})}function tt(t,n,r){if(null!=r&&r.useTransform){var e;const{position:o,normal:a,tangent:i}=t;return{vertexAttributes:{position:o,normal:a,tangent:i},transform:new J({origin:[n.x,n.y,null!=(e=n.z)?e:0],geographic:K(n.spatialReference,r)})}}return{vertexAttributes:Q(t,n,r),transform:null}}function nt(t,n,r){return K(n.spatialReference,r)?it(t,n,r):at(t,n,r)}function rt(t,n,r,e){if(b(n))return nt(t,r,e);const o=X(t,n,r.spatialReference);return r.equals(n.getOriginPoint(r.spatialReference))?at(o,r,e):K(r.spatialReference,e)?it(o,r,e):at(o,r,e)}function et(t,n,r,e,o){if(b(r))return null;const a=new Float32Array(r.length);return k(E.fromTypedArray(a),E.fromTypedArray(r),e),G(a,t,n,o,a),a}function ot(t,n,r,e,o){if(b(r))return null;const a=new Float32Array(r.length);k(E.fromTypedArray(a,4*Float32Array.BYTES_PER_ELEMENT),E.fromTypedArray(r,4*Float32Array.BYTES_PER_ELEMENT),e);for(let i=3;i<a.length;i+=4)a[i]=r[i];return S(a,t,n,o,a),a}function at(t,n,r){const e=new Float64Array(t.position.length),o=t.position,a=n.x,i=n.y,s=n.z||0,{horizontal:l,vertical:c}=pt(r?r.unit:null,n.spatialReference);for(let p=0;p<o.length;p+=3)e[p+0]=(o[p+0]-a)/l,e[p+1]=(o[p+1]-i)/l,e[p+2]=(o[p+2]-s)/c;return{position:e,normal:t.normal,tangent:t.tangent}}function it(t,n,r){const e=n.spatialReference;st(n,r,ut);const o=c(gt,ut),a=new Float64Array(t.position.length),i=function(t,n,r,e){const o=$(t,n,e),a=g.fromTypedArray(o),i=new Float64Array(o.length),s=g.fromTypedArray(i);return O(s,a,r),i}(t.position,e,o,a),s=R(ft,o);return{position:i,normal:lt(t.normal,t.position,a,e,s),tangent:ct(t.tangent,t.position,a,e,s)}}function st(t,n,r){y(t.spatialReference,[t.x,t.y,t.z||0],r,j(t.spatialReference));const{horizontal:e,vertical:o}=pt(n?n.unit:null,t.spatialReference);return i(r,r,[e,e,o]),r}function lt(t,n,r,e,o){if(b(t))return null;const a=V(t,n,r,e,new Float32Array(t.length)),i=E.fromTypedArray(a);return k(i,i,o),a}function ct(t,n,r,e,o){if(b(t))return null;const a=W(t,n,r,e,new Float32Array(t.length)),i=E.fromTypedArray(a,4*Float32Array.BYTES_PER_ELEMENT);return k(i,i,o),a}function pt(t,n){if(b(t))return ht;const r=n.isGeographic?1:N(n),e=n.isGeographic?1:z(n),o=_(1,t,"meters");return{horizontal:o*r,vertical:o*e}}const ut=p(),gt=p(),ft=L(),ht={horizontal:1,vertical:1};export{nt as M,J as O,rt as P,X as _,tt as k,K as r,Q as x};
