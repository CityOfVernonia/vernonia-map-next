import{aq as i,g1 as n,c2 as s,ii as t,g0 as a,hw as e,gh as o,bX as r,ij as c,ik as u,il as g,b_ as b,hm as l,fZ as f,f3 as p,bY as d,im as h,io as I,gc as m,ip as P,bZ as N,iq as w,hn as M,ir as v,gX as T,is as _,hA as x,it as A,f$ as V,iu as y,iv as E,ge as S,iw as j,gD as q,cQ as O,gd as Y,ix as F,h4 as k,gx as B,fD as C,ho as R,g2 as U}from"./vendor.9770a310.js";const D=i.getLogger("esri.views.3d.support.geometryUtils.boundedPlane");function L(i=ci){return{plane:n(i.plane),origin:e(i.origin),basis1:e(i.basis1),basis2:e(i.basis2)}}function X(i,n=L()){return Z(i.origin,i.basis1,i.basis2,n)}function Z(i,n,s,t=L()){return o(t.origin,i),o(t.basis1,n),o(t.basis2,s),z(t),function(i,n){Math.abs(T(i.basis1,i.basis2)/(N(i.basis1)*N(i.basis2)))>1e-6&&D.warn(n,"Provided basis vectors are not perpendicular"),Math.abs(T(i.basis1,ti(i)))>1e-6&&D.warn(n,"Basis vectors and plane normal are not perpendicular"),Math.abs(-T(ti(i),i.origin)-i.plane[3])>1e-6&&D.warn(n,"Plane offset is not consistent with plane origin")}(t,"fromValues()"),t}function z(i){g(i.basis2,i.basis1,i.origin,i.plane)}function G(i,n,s){i!==s&&X(i,s);const t=b(f.get(),ti(i),n);return p(s.origin,s.origin,t),s.plane[3]-=n,s}function Q(i,n=L()){const s=(i[2]-i[0])/2,t=(i[3]-i[1])/2;return d(n.origin,i[0]+s,i[1]+t,0),d(n.basis1,s,0,0),d(n.basis2,0,t,0),h(0,0,1,0,n.plane),n}function W(i,n,s){return!!m(i.plane,n,s)&&ai(i,s)}function $(i,n,s){const t=ui.get();ri(i,n,t,ui.get());let a=Number.POSITIVE_INFINITY;for(const e of fi){const r=oi(i,e,gi.get()),c=f.get();if(w(t,r,c)){const i=M(f.get(),n.origin,c),t=Math.abs(v(T(n.direction,i)));t<a&&(a=t,o(s,c))}}return a===Number.POSITIVE_INFINITY?H(i,n,s):s}function H(i,n,s){if(W(i,n,s))return s;const t=ui.get(),a=ui.get();ri(i,n,t,a);let e=Number.POSITIVE_INFINITY;for(const r of fi){const c=oi(i,r,gi.get()),u=f.get();if(_(t,c,u)){const i=x(n,u);if(!A(a,u))continue;i<e&&(e=i,o(s,u))}}return ii(i,n.origin)<e&&J(i,n.origin,s),s}function J(i,n,s){const t=y(i.plane,n,f.get()),a=E(ei(i,i.basis1),t,-1,1,f.get()),e=E(ei(i,i.basis2),t,-1,1,f.get());return V(s,p(f.get(),a,e),i.origin),s}function K(i,n,s){const{origin:t,basis1:a,basis2:e}=i,o=V(f.get(),n,t),r=I(a,o),c=I(e,o),u=I(ti(i),o);return d(s,r,c,u)}function ii(i,n){const s=K(i,n,f.get()),{basis1:t,basis2:a}=i,e=N(t),o=N(a),r=Math.max(Math.abs(s[0])-e,0),c=Math.max(Math.abs(s[1])-o,0),u=s[2];return r*r+c*c+u*u}function ni(i,n){return Math.sqrt(ii(i,n))}function si(i,n){const s=-i.plane[3];return I(ti(i),n)-s}function ti(i){return l(i.plane)}function ai(i,n){const s=V(f.get(),n,i.origin),t=R(i.basis1),a=R(i.basis2),e=T(i.basis1,s),o=T(i.basis2,s);return-e-t<0&&e-t<0&&-o-a<0&&o-a<0}function ei(i,n){const s=gi.get();return o(s.origin,i.origin),o(s.vector,n),s}function oi(i,n,s){const{basis1:t,basis2:a,origin:e}=i,o=b(f.get(),t,n.origin[0]),r=b(f.get(),a,n.origin[1]);p(s.origin,o,r),p(s.origin,s.origin,e);const c=b(f.get(),t,n.direction[0]),u=b(f.get(),a,n.direction[1]);return b(s.vector,p(c,c,u),2),s}function ri(i,n,s,t){const a=ti(i);g(a,n.direction,n.origin,s),g(l(s),a,n.origin,t)}const ci={plane:n(),origin:s(0,0,0),basis1:s(1,0,0),basis2:s(0,1,0)},ui=new t(n),gi=new t(a),bi=r(),li=new t((()=>({origin:null,basis1:null,basis2:null,plane:null}))),fi=[{origin:[-1,-1],direction:[1,0]},{origin:[1,-1],direction:[0,1]},{origin:[1,1],direction:[-1,0]},{origin:[-1,1],direction:[0,-1]}],pi=U(),di=U();Object.freeze({__proto__:null,BoundedPlaneClass:class{constructor(){this.plane=n(),this.origin=r(),this.basis1=r(),this.basis2=r()}},create:L,wrap:function(i,n,s){const t=li.get();return t.origin=i,t.basis1=n,t.basis2=s,t.plane=c(0,0,0,0),z(t),t},copy:X,copyWithoutVerify:function(i,n){o(n.origin,i.origin),o(n.basis1,i.basis1),o(n.basis2,i.basis2),u(i.plane,n.plane)},fromValues:Z,updateUnboundedPlane:z,elevate:G,setExtent:function(i,n,s){return Q(n,s),G(s,si(i,i.origin),s),s},fromAABoundingRect:Q,intersectRay:W,intersectRayClosestSilhouette:function(i,n,s){if(W(i,n,s))return s;const t=$(i,n,f.get());return p(s,n.origin,b(f.get(),n.direction,P(n.origin,t)/N(n.direction))),s},closestPointOnSilhouette:$,closestPoint:H,projectPoint:J,projectPointLocal:K,distance2:ii,distance:ni,distanceToSilhouette:function(i,n){let s=Number.NEGATIVE_INFINITY;for(const t of fi){const a=oi(i,t,gi.get()),e=S(a,n);e>s&&(s=e)}return Math.sqrt(s)},extrusionContainsPoint:function(i,n){return A(i.plane,n)&&ai(i,n)},axisAt:function(i,n,s,t){return function(i,n,s){switch(n){case 0:o(s,i.basis1),C(s,s);break;case 1:o(s,i.basis2),C(s,s);break;case 2:o(s,ti(i))}return s}(i,s,t)},altitudeAt:si,setAltitudeAt:function(i,n,s,t){const a=si(i,n),e=b(bi,ti(i),s-a);return p(t,n,e),t},equals:function(i,n){return j(i.basis1,n.basis1)&&j(i.basis2,n.basis2)&&j(i.origin,n.origin)},transform:function(i,n,s){return i!==s&&X(i,s),q(pi,n),O(pi,pi),Y(s.basis1,i.basis1,pi),Y(s.basis2,i.basis2,pi),Y(l(s.plane),l(i.plane),pi),Y(s.origin,i.origin,n),F(s.plane,s.origin,s.plane),s},rotate:function(i,n,s,t){return i!==t&&X(i,t),k(di,B(di),n,s),Y(t.basis1,i.basis1,di),Y(t.basis2,i.basis2,di),z(t),t},normal:ti,UP:ci});export{X as D,L as G,z as K,Q as Z,ni as o};
