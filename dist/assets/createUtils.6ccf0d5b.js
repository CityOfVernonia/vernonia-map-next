import{i9 as a,ia as e,ib as t,cu as n,D as s,ab as o,z as r,eL as l,B as i,ai as c,ic as x,H as y,id as u,bh as p,ie as h,ef as f,ig as M,ih as m}from"./vendor.9770a310.js";function d(a,e,t=null){return o(t)?[a,e,t]:[a,e]}function R(a,e){const t=new r({x:a[0],y:a[1],spatialReference:e});return a.length>2&&(t.z=a[2]),t}function b(a,e){return new l({points:a,spatialReference:e})}function g(a,e,n){const s=new i({paths:a,spatialReference:e});return n&&t(s),s}function T(a,o,r,l=!0){const i=c(a);i.forEach((a=>{const e=a[0],t=a[a.length-1];x(e,t)&&1!==a.length||a.push(a[0])}));let u=new y({rings:i,spatialReference:o});return u.rings.forEach((a=>{e(a,!1,!1)||a.reverse()})),r&&t(u),l&&u.isSelfIntersecting&&n(o)&&(u=s(u)),u}function z(e,t,n){const s=t.mapToLocalMultiple(e),o=[],r={x:s[0].x,y:s[0].y},l=s[1].x,i=s[1].y,c=Math.round(l-r.x),x=Math.round(i-r.y),y=Math.max(Math.abs(c),Math.abs(x));if(n){const a={x:r.x+y,y:r.y+y},e={x:r.x-y,y:r.y-y};o.push(u(a.x,e.y),u(e.x,e.y),u(e.x,a.y),u(a.x,a.y))}else{const a={x:c>0?r.x+y:r.x-y,y:x>0?r.y+y:r.y-y};o.push(u(r.x,r.y),u(a.x,r.y),u(a.x,a.y),u(r.x,a.y))}return T([a(o.map((a=>t.localToMap(a))))],t.spatialReference,t.doUnnormalization,!0)}function w(e,t,n){let s=t.mapToLocalMultiple(e);if(1===s.length){const a=48,e=s[0];s=[u(e.x-a,e.y+a),u(e.x+a,e.y-a),u(e.x+a,e.y-a),u(e.x-a,e.y+a)]}const o=[],r={x:s[0].x,y:s[0].y},l={x:s[1].x,y:s[1].y};if(n){const a=Math.round(l.x-r.x),e=Math.round(l.y-r.y);o.push(u(r.x-a,r.y-e),u(l.x,r.y-e),u(l.x,l.y),u(r.x-a,l.y))}else o.push(u(r.x,r.y),u(l.x,r.y),u(l.x,l.y),u(r.x,l.y));return T([a(o.map((a=>t.localToMap(a))))],t.spatialReference,t.doUnnormalization,!0)}function L(a,e,t,s){const o=e.mapToLocalMultiple(a);let r=null,l=null;if(t)r=o[0],l=o[1];else{const a=o[0],e=o[1],t=Math.round(e.x-a.x),n=Math.round(e.y-a.y),s=Math.max(Math.abs(t),Math.abs(n));r=u(t>0?a.x+s/2:a.x-s/2,n>0?a.y+s/2:a.y-s/2),l=u(Math.abs(t)>Math.abs(n)?r.x-s/2:r.x,Math.abs(t)>Math.abs(n)?r.y:r.y-s/2)}const i=e.localToMap(r),c=e.localToMap(l);if(p(i)||p(c))return null;e.doUnnormalization&&h([[i,c]],e.spatialReference);const x=R(i,e.spatialReference),y=R(c,e.spatialReference),d=f(e.spatialReference);let b=0;if(n(e.spatialReference))b=d*M(x,y,null);else{const a=r.x-l.x,e=r.y-l.y;b=d*Math.sqrt(a*a+e*e)*(s||1)}const g=new m({center:x,radius:b,radiusUnit:"meters",spatialReference:e.spatialReference});return T(g.rings,g.spatialReference,!1)}function P(e,t,n){const s=t.mapToLocalMultiple(e),o=s[0],r=s[1],l=Math.round(r.x-o.x),i=Math.round(r.y-o.y),c=u(n?o.x:o.x+l/2,n?o.y:o.y+i/2),x=n?l:l/2,y=n?i:i/2,p=[],h=2*Math.PI/60;for(let a=0;a<60;a++){const e=Math.cos(a*h),t=Math.sin(a*h),n=u(x*e+c.x,y*t+c.y);p.push(n)}return p.push(p[0]),T([a(p.map((a=>t.localToMap(a))))],t.spatialReference,t.doUnnormalization,!1)}export{L as createCircle,P as createEllipse,b as createMultipoint,R as createPoint,T as createPolygon,g as createPolyline,w as createRectangle,z as createSquare,d as makeMapPoint};
