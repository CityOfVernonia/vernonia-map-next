import{i6 as a,i7 as e,i8 as t,cr as n,A as s,a8 as o,v as r,eI as l,z as c,af as i,i9 as x,E as y,ia as u,be as p,ib as f,ec as h,ic as M,id as m}from"./vendor.c9efa5f2.js";function d(a,e,t=null){return o(t)?[a,e,t]:[a,e]}function R(a,e){const t=new r({x:a[0],y:a[1],spatialReference:e});return a.length>2&&(t.z=a[2]),t}function b(a,e){return new l({points:a,spatialReference:e})}function g(a,e,n){const s=new c({paths:a,spatialReference:e});return n&&t(s),s}function T(a,o,r,l=!0){const c=i(a);c.forEach((a=>{const e=a[0],t=a[a.length-1];x(e,t)&&1!==a.length||a.push(a[0])}));let u=new y({rings:c,spatialReference:o});return u.rings.forEach((a=>{e(a,!1,!1)||a.reverse()})),r&&t(u),l&&u.isSelfIntersecting&&n(o)&&(u=s(u)),u}function z(e,t,n){const s=t.mapToLocalMultiple(e),o=[],r={x:s[0].x,y:s[0].y},l=s[1].x,c=s[1].y,i=Math.round(l-r.x),x=Math.round(c-r.y),y=Math.max(Math.abs(i),Math.abs(x));if(n){const a={x:r.x+y,y:r.y+y},e={x:r.x-y,y:r.y-y};o.push(u(a.x,e.y),u(e.x,e.y),u(e.x,a.y),u(a.x,a.y))}else{const a={x:i>0?r.x+y:r.x-y,y:x>0?r.y+y:r.y-y};o.push(u(r.x,r.y),u(a.x,r.y),u(a.x,a.y),u(r.x,a.y))}return T([a(o.map((a=>t.localToMap(a))))],t.spatialReference,t.doUnnormalization,!0)}function w(e,t,n){let s=t.mapToLocalMultiple(e);if(1===s.length){const a=48,e=s[0];s=[u(e.x-a,e.y+a),u(e.x+a,e.y-a),u(e.x+a,e.y-a),u(e.x-a,e.y+a)]}const o=[],r={x:s[0].x,y:s[0].y},l={x:s[1].x,y:s[1].y};if(n){const a=Math.round(l.x-r.x),e=Math.round(l.y-r.y);o.push(u(r.x-a,r.y-e),u(l.x,r.y-e),u(l.x,l.y),u(r.x-a,l.y))}else o.push(u(r.x,r.y),u(l.x,r.y),u(l.x,l.y),u(r.x,l.y));return T([a(o.map((a=>t.localToMap(a))))],t.spatialReference,t.doUnnormalization,!0)}function P(a,e,t,s){const o=e.mapToLocalMultiple(a);let r=null,l=null;if(t)r=o[0],l=o[1];else{const a=o[0],e=o[1],t=Math.round(e.x-a.x),n=Math.round(e.y-a.y),s=Math.max(Math.abs(t),Math.abs(n));r=u(t>0?a.x+s/2:a.x-s/2,n>0?a.y+s/2:a.y-s/2),l=u(Math.abs(t)>Math.abs(n)?r.x-s/2:r.x,Math.abs(t)>Math.abs(n)?r.y:r.y-s/2)}const c=e.localToMap(r),i=e.localToMap(l);if(p(c)||p(i))return null;e.doUnnormalization&&f([[c,i]],e.spatialReference);const x=R(c,e.spatialReference),y=R(i,e.spatialReference),d=h(e.spatialReference);let b=0;if(n(e.spatialReference))b=d*M(x,y,null);else{const a=r.x-l.x,e=r.y-l.y;b=d*Math.sqrt(a*a+e*e)*(s||1)}const g=new m({center:x,radius:b,radiusUnit:"meters",spatialReference:e.spatialReference});return T(g.rings,g.spatialReference,!1)}function U(e,t,n){const s=t.mapToLocalMultiple(e),o=s[0],r=s[1],l=Math.round(r.x-o.x),c=Math.round(r.y-o.y),i=u(n?o.x:o.x+l/2,n?o.y:o.y+c/2),x=n?l:l/2,y=n?c:c/2,p=[],f=2*Math.PI/60;for(let a=0;a<60;a++){const e=Math.cos(a*f),t=Math.sin(a*f),n=u(x*e+i.x,y*t+i.y);p.push(n)}return p.push(p[0]),T([a(p.map((a=>t.localToMap(a))))],t.spatialReference,t.doUnnormalization,!1)}export{P as createCircle,U as createEllipse,b as createMultipoint,R as createPoint,T as createPolygon,g as createPolyline,w as createRectangle,z as createSquare,d as makeMapPoint};
