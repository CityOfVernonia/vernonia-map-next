var e=Object.defineProperty,t=Object.defineProperties,n=Object.getOwnPropertyDescriptors,o=Object.getOwnPropertySymbols,s=Object.prototype.hasOwnProperty,r=Object.prototype.propertyIsEnumerable,a=(t,n,o)=>n in t?e(t,n,{enumerable:!0,configurable:!0,writable:!0,value:o}):t[n]=o;import{n as i}from"./deduplicate.a6019262.js";import{oK as c,li as l,fL as f,lk as u,lh as g,oL as d,oM as p,oN as h,kY as m,lj as w,lQ as v,lg as y,ll as b,nc as A,mP as I,lO as S,n7 as L,na as N,mQ as V,mO as O,n6 as x,n9 as E,oO as P,oP as D,oQ as j,nd as U,oR as W,oS as k,oT as F,nb as M,oU as B,oV as T,oW as $,oX as C,oY as Q,oZ as R,fI as X,j1 as Y,f3 as z,fD as H,bX as _,e7 as q,gw as K,o_ as Z,o$ as G,bY as J,gh as ee,gX as te,gC as ne,ir as oe,hn as se,f$ as re,ip as ae}from"./vendor.9770a310.js";function ie(e,t,n){const o=t/3,s=new Uint32Array(n+1),r=new Uint32Array(n+1),a=(e,t)=>{e<t?s[e+1]++:r[t+1]++};for(let w=0;w<o;w++){const t=e[3*w],n=e[3*w+1],o=e[3*w+2];a(t,n),a(n,o),a(o,t)}let i=0,c=0;for(let w=0;w<n;w++){const e=s[w+1],t=r[w+1];s[w+1]=i,r[w+1]=c,i+=e,c+=t}const l=new Uint32Array(6*o),f=s[n],u=(e,t,n)=>{if(e<t){const o=s[e+1]++;l[2*o]=t,l[2*o+1]=n}else{const o=r[t+1]++;l[2*f+2*o]=e,l[2*f+2*o+1]=n}};for(let w=0;w<o;w++){const t=e[3*w],n=e[3*w+1],o=e[3*w+2];u(t,n,w),u(n,o,w),u(o,t,w)}const g=(e,t)=>{const n=2*e,o=t-e;for(let s=1;s<o;s++){const e=l[n+2*s],t=l[n+2*s+1];let o=s-1;for(;o>=0&&l[n+2*o]>e;o--)l[n+2*o+2]=l[n+2*o],l[n+2*o+3]=l[n+2*o+1];l[n+2*o+2]=e,l[n+2*o+3]=t}};for(let w=0;w<n;w++)g(s[w],s[w+1]),g(f+r[w],f+r[w+1]);const d=new Int32Array(3*o),p=(t,n)=>t===e[3*n]?0:t===e[3*n+1]?1:t===e[3*n+2]?2:-1,h=(e,t)=>{const n=p(e,t);d[3*t+n]=-1},m=(e,t,n,o)=>{const s=p(e,t);d[3*t+s]=o;const r=p(n,o);d[3*o+r]=t};for(let w=0;w<n;w++){let e=s[w];const t=s[w+1];let n=r[w];const o=r[w+1];for(;e<t&&n<o;){const t=l[2*e],o=l[2*f+2*n];t===o?(m(w,l[2*e+1],o,l[2*f+2*n+1]),e++,n++):t<o?(h(w,l[2*e+1]),e++):(h(o,l[2*f+2*n+1]),n++)}for(;e<t;)h(w,l[2*e+1]),e++;for(;n<o;)h(l[2*f+2*n],l[2*f+2*n+1]),n++}return d}function ce(e,t){return t.push(e.buffer),{buffer:e.buffer,layout:le(e.layout)}}function le(e){const i=new Array;return e.fields.forEach(((e,c)=>{const l=(f=((e,t)=>{for(var n in t||(t={}))s.call(t,n)&&a(e,n,t[n]);if(o)for(var n of o(t))r.call(t,n)&&a(e,n,t[n]);return e})({},e),u={constructor:ue(e.constructor)},t(f,n(u)));var f,u;i.push([c,l])})),{stride:e.stride,fields:i,fieldNames:e.fieldNames}}const fe=[c,l,f,u,g,d,p,h,m,w,v,y,b,A,I,S,L,N,V,O,x,E,P,D,j,U,W,k,F,M,B,T,$,C,Q,R];function ue(e){return`${e.ElementType}_${e.ElementCount}`}const ge=new Map;fe.forEach((e=>ge.set(ue(e),e)));const de=X().vec3f("position").u16("componentIndex").u16("u16padding");Y(X().vec2u8("sideness"));const pe=X().vec3f("position0").vec3f("position1").u16("componentIndex").u8("variantOffset",{glNormalized:!0}).u8("variantStroke").u8("variantExtension",{glNormalized:!0}).u8("u8padding",{glPadding:!0}).u16("u16padding",{glPadding:!0}),he=pe.clone().vec3f("normal"),me=pe.clone().vec3f("normalA").vec3f("normalB");class we{updateSettings(e){this.settings=e,this.edgeHashFunction=e.reducedPrecision?Ie:Ae}write(e,t,n){const o=this.edgeHashFunction(n);Oe.seed=o;const s=Oe.getIntRange(0,255),r=Oe.getIntRange(0,this.settings.variants-1),a=Oe.getFloat(),i=255*(.5*function(e,t){const n=e<0?-1:1;return Math.abs(e)**t*n}(-(1-Math.min(a/.7,1))+Math.max(0,a-.7)/(1-.7),1.2)+.5);e.position0.setVec(t,n.position0),e.position1.setVec(t,n.position1),e.componentIndex.set(t,n.componentIndex),e.variantOffset.set(t,s),e.variantStroke.set(t,r),e.variantExtension.set(t,i)}trim(e,t){return e.slice(0,t)}}const ve=new Float32Array(6),ye=new Uint32Array(ve.buffer),be=new Uint32Array(1);function Ae(e){const t=ve;t[0]=e.position0[0],t[1]=e.position0[1],t[2]=e.position0[2],t[3]=e.position1[0],t[4]=e.position1[1],t[5]=e.position1[2],be[0]=5381;for(let n=0;n<ye.length;n++)be[0]=31*be[0]+ye[n];return be[0]}function Ie(e){const t=ve;t[0]=Se(e.position0[0]),t[1]=Se(e.position0[1]),t[2]=Se(e.position0[2]),t[3]=Se(e.position1[0]),t[4]=Se(e.position1[1]),t[5]=Se(e.position1[2]),be[0]=5381;for(let n=0;n<ye.length;n++)be[0]=31*be[0]+ye[n];return be[0]}function Se(e){return Math.round(1e4*e)/1e4}class Le{constructor(){this.commonWriter=new we}updateSettings(e){this.commonWriter.updateSettings(e)}allocate(e){return he.createBuffer(e)}write(e,t,n){this.commonWriter.write(e,t,n),z(Ve,n.faceNormal0,n.faceNormal1),H(Ve,Ve),e.normal.setVec(t,Ve)}trim(e,t){return this.commonWriter.trim(e,t)}}Le.Layout=he,Le.glLayout=Y(he,1);class Ne{constructor(){this.commonWriter=new we}updateSettings(e){this.commonWriter.updateSettings(e)}allocate(e){return me.createBuffer(e)}write(e,t,n){this.commonWriter.write(e,t,n),e.normalA.setVec(t,n.faceNormal0),e.normalB.setVec(t,n.faceNormal1)}trim(e,t){return this.commonWriter.trim(e,t)}}Ne.Layout=me,Ne.glLayout=Y(me,1);const Ve=_(),Oe=new q,xe=-1;function Ee(e,t,n,o=ke){const s=e.vertices.position,r=e.vertices.componentIndex,a=K(o.anglePlanar),i=K(o.angleSignificantEdge),c=Math.cos(i),l=Math.cos(a),f=Ue.edge,u=f.position0,g=f.position1,d=f.faceNormal0,p=f.faceNormal1,h=function(e){const t=e.faces.length/3,n=e.vertices.position,o=e.faces,s=We.v0,r=We.v1,a=We.v2,i=new Float32Array(3*t);for(let c=0;c<t;c++){const e=o[3*c+0],t=o[3*c+1],l=o[3*c+2];n.getVec(e,s),n.getVec(t,r),n.getVec(l,a),re(r,r,s),re(a,a,s),ne(s,r,a),H(s,s),i[3*c+0]=s[0],i[3*c+1]=s[1],i[3*c+2]=s[2]}return i}(e),m=function(e){const t=e.faces.length/3,n=e.faces,o=e.neighbors;let s=0;for(let i=0;i<t;i++){const e=o[3*i+0],t=o[3*i+1],r=o[3*i+2],a=n[3*i+0],c=n[3*i+1],l=n[3*i+2];s+=e===xe||a<c?1:0,s+=t===xe||c<l?1:0,s+=r===xe||l<a?1:0}const r=new Int32Array(4*s);let a=0;for(let i=0;i<t;i++){const e=o[3*i+0],t=o[3*i+1],s=o[3*i+2],c=n[3*i+0],l=n[3*i+1],f=n[3*i+2];(e===xe||c<l)&&(r[a++]=c,r[a++]=l,r[a++]=i,r[a++]=e),(t===xe||l<f)&&(r[a++]=l,r[a++]=f,r[a++]=i,r[a++]=t),(s===xe||f<c)&&(r[a++]=f,r[a++]=c,r[a++]=i,r[a++]=s)}return r}(e),w=m.length/4,v=t.allocate(w);let y=0;const b=w,A=n.allocate(b);let I=0,S=0,L=0;const N=Z(0,w),V=new Float32Array(w);G(V,((e,t,n)=>{s.getVec(m[4*t+0],u),s.getVec(m[4*t+1],g),n[t]=ae(u,g)})),N.sort(((e,t)=>V[t]-V[e]));const O=new Array,x=new Array;for(let D=0;D<w;D++){const e=N[D],o=V[e],i=m[4*e+0],w=m[4*e+1],b=m[4*e+2],E=m[4*e+3],P=E===xe;if(s.getVec(i,u),s.getVec(w,g),P)J(d,h[3*b+0],h[3*b+1],h[3*b+2]),ee(p,d),f.componentIndex=r.get(i),f.cosAngle=te(d,p);else{if(J(d,h[3*b+0],h[3*b+1],h[3*b+2]),J(p,h[3*E+0],h[3*E+1],h[3*E+2]),f.componentIndex=r.get(i),f.cosAngle=te(d,p),De(f,l))continue;f.cosAngle<-.9999&&ee(p,d)}S+=o,L++,P||Pe(f,c)?(t.write(v,y++,f),O.push(o)):je(f,a)&&(n.write(A,I++,f),x.push(o))}const E=new Float32Array(O.reverse()),P=new Float32Array(x.reverse());return{regular:{instancesData:t.trim(v,y),lodInfo:{lengths:E}},silhouette:{instancesData:n.trim(A,I),lodInfo:{lengths:P}},averageEdgeLength:S/L}}function Pe(e,t){return e.cosAngle<t}function De(e,t){return e.cosAngle>t}function je(e,t){const n=oe(e.cosAngle),o=Ue.fwd,s=Ue.ortho;return se(o,e.position1,e.position0),n*(te(ne(s,e.faceNormal0,e.faceNormal1),o)>0?-1:1)>t}const Ue={edge:{position0:_(),position1:_(),faceNormal0:_(),faceNormal1:_(),componentIndex:0,cosAngle:0},ortho:_(),fwd:_()},We={v0:_(),v1:_(),v2:_()},ke={anglePlanar:4,angleSignificantEdge:35};async function Fe(e){const t=(s=e,{data:de.createView(s.dataBuffer),indices:"Uint32Array"===s.indicesType?new Uint32Array(s.indicesBuffer):"Uint16Array"===s.indicesType?new Uint16Array(s.indicesBuffer):void 0,indicesLength:s.indicesLength,writerSettings:s.writerSettings,skipDeduplicate:s.skipDeduplicate}),n=Me(t),o=[t.data.buffer];var s;return{result:Be(n,o),transferList:o}}function Me(e){const t=function(e,t,n,o){if(t)return{faces:n,facesLength:o,neighbors:ie(n,o,e.count),vertices:e};const s=i(e.buffer,e.stride/4,{originalIndices:n,originalIndicesLength:o}),r=ie(s.indices,o,s.uniqueCount);return{faces:s.indices,facesLength:s.indices.length,neighbors:r,vertices:de.createView(s.buffer)}}(e.data,e.skipDeduplicate,e.indices,e.indicesLength);return Te.updateSettings(e.writerSettings),$e.updateSettings(e.writerSettings),Ee(t,Te,$e)}function Be(e,t){return t.push(e.regular.lodInfo.lengths.buffer),t.push(e.silhouette.lodInfo.lengths.buffer),{regular:{instancesData:ce(e.regular.instancesData,t),lodInfo:{lengths:e.regular.lodInfo.lengths.buffer}},silhouette:{instancesData:ce(e.silhouette.instancesData,t),lodInfo:{lengths:e.silhouette.lodInfo.lengths.buffer}},averageEdgeLength:e.averageEdgeLength}}const Te=new Le,$e=new Ne;export{Me as work,Fe as wrappedWork};
